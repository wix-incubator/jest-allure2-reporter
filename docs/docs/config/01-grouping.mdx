---
description: View test results in multiple cross-sections to gain insights quickly.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Grouping

:::caution

This website version refers to the unreleased version of `jest-allure2-reporter` and is not yet available
anywhere. Please use GitHub docs for the latest stable version.

:::

Allure reports are designed to be clear and accessible to all team members, making it easier to interpret test results.

**Grouping** is a feature that allows you to view test results from different perspectives and gain insights quickly.

There are four main ways to group test results in Allure reports:

## By Suite :star:

This is the default grouping option, and it makes the most sense for projects using Jest.

The suite hierarchy consists of up to four levels: **parent suite**, **suite**, **subsuite**, and **test case**.


```plain
Parent suite
â”œâ”€ Suite
â”‚  â”œâ”€ Subsuite
â”‚  â”‚  â”œâ”€ Test case
â”‚  â”‚  â””â”€ Test case
â”‚  â””â”€ Subsuite
â”‚     â”œâ”€ Test case
â”‚     â””â”€ Test case
```

The **parent suite** is the highest level of the hierarchy and is used to group test results by package (e.g. `client`, `server`), test directory (e.g. `e2e`, `unit`, `integration`) or any other criteria that makes sense for your project. It is not configured by default, but you can easily add it to your reports.

The **suite** serves as the primary grouping level, typically based on test file paths. However, you can choose alternative criteria such as feature or component directories (`LoginScreen`, `ProfileScreen`, `core`, `utils`) or a top-level describe block names, if you prefer.

The **subsuite** level is helpful when dealing with a large number of test cases within a single suite. By default, it groups test cases based on the top-level describe block. However, if you have numerous nested describe blocks or prefer more file system-based splitting, alternative configurations can be explored.

The **test case** level represents the actual test. By default, it displays the test name, including the inner describe block names. You have the flexibility to choose a test name format that best suits your needs â€“ see a few examples below of how to configure the grouping levels.

### Default structure

It uses 3 levels of grouping: **suite**, **subsuite**, and **test case**:

* The **suite** level is based on the test file path.
* The **subsuite** level is based on the top-level describe block.
* The **test case** level is based on the test name (including the inner describe block names).

<Tabs groupId="grouping-default">
  <TabItem value="structure" label="Structure">

```plain
â”œâ”€ client/auth/LoginScreen.test.js
â”‚  â””â”€ Login screen
â”‚     â”œâ”€ when loaded should display login form
â”‚     â””â”€ when loaded and typed should validate e-mail
â”‚     â””â”€ when loaded and typed should validate password
â”œâ”€ client/auth/ForgotPasswordScreen.test.js
â”‚  â””â”€ Forgot password screen
â”‚     â”œâ”€ when loaded should display forgot password form
â”‚     â””â”€ when loaded and typed should validate e-mail
â”œâ”€ server/controllers/login.test.js
|  â””â”€ Login controller
|     â”œâ”€ should return 401 if user is not found
|     â””â”€ should return 401 if password is incorrect
â””â”€ server/controllers/forgotPassword.test.js
   â””â”€ Forgot password controller
      â”œâ”€ should return 401 if user is not found
      â””â”€ should return 401 if password is incorrect
```

  </TabItem>
  <TabItem value="config" label="Config">

```js title="jest.config.js"
/** @type {import('@jest/types').Config.InitialOptions} */
module.exports = {
  testEnvironment: 'jest-allure2-reporter/environment-node',
  reporters: [
    'default',
    'jest-allure2-reporter',
    // You don't need to configure anything special
    // to get this structure.
  ],
};
```

  </TabItem>
</Tabs>

### File-oriented example

This example might be useful for projects with many test files and relatively few test cases per file.

<Tabs groupId="grouping-default">
  <TabItem value="structure" label="Structure">

```plain
â”œâ”€ client
â”‚  â””â”€ auth
â”‚     â”œâ”€ LoginScreen.test.js
â”‚     â”‚  â”œâ”€ Login screen when loaded should display login form
â”‚     â”‚  â”œâ”€ Login screen when loaded and typed should validate e-mail
â”‚     â”‚  â””â”€ Login screen when loaded and typed should validate password
â”‚     â””â”€ ForgotPasswordScreen.test.js
â”‚        â”œâ”€ Forgot password screen when loaded should display forgot password form
â”‚        â””â”€ Forgot password screen when loaded and typed should validate e-mail
â””â”€ server
   â””â”€ controllers
      â”œâ”€ login.test.js
      â”‚  â”œâ”€ Login controller should return 401 if user is not found
      â”‚  â””â”€ Login controller should return 401 if password is incorrect
      â””â”€ ForgotPasswordScreen.test.js
         â”œâ”€ Forgot password controller should return 401 if user is not found
         â””â”€ Forgot password controller should return 401 if password is incorrect
```

  </TabItem>
  <TabItem value="config" label="Config">

```js title="jest.config.js"
/** @type {import('@jest/types').Config.InitialOptions} */
module.exports = {
  testEnvironment: 'jest-allure2-reporter/environment-node',
  reporters: [
    'default',
    ['jest-allure2-reporter', /** @type {import('jest-allure2-reporter').Options}*/
      {
        labels: {
          parentSuite: ({ file }) => file.pathSegments[0],
          suite: ({ file }) => file.pathSegments.slice(1, -1).join(' '),
          subsuite: ({ file }) => file.pathSegments.slice(-1)[0],
          test: ({ test }) => test.fullName,
        },
      },
    ],
  ],
};
```

  </TabItem>
</Tabs>

### Test-oriented example

<Tabs groupId="grouping-default">
  <TabItem value="structure" label="Structure">

```plain
â”œâ”€ client/auth/LoginScreen.test.js
â”‚  â”œâ”€ Login screen
â”‚  â”‚  â”œâ”€ when loaded
â”‚  â”‚  â”‚  â””â”€ should display login form
â”‚  â”‚  â””â”€ when loaded and typed
â”‚  â”‚     â”œâ”€ should validate e-mail
â”‚  â”‚     â””â”€ should validate password
â”‚  â””â”€ Forgot password screen
â”‚     â”œâ”€ when loaded
â”‚     â”‚  â””â”€ should display forgot password form
â”‚     â””â”€ when loaded and typed
â”‚        â””â”€ should validate e-mail
â””â”€ server/controllers/login.test.js
   â”œâ”€ Login controller
   â”‚  â”œâ”€ should return 401 if user is not found
   â”‚  â””â”€ should return 401 if password is incorrect
   â””â”€ Forgot password controller
      â”œâ”€ should return 401 if user is not found
      â””â”€ should return 401 if password is incorrect
```

  </TabItem>
  <TabItem value="config" label="Config">

```js title="jest.config.js"
/** @type {import('@jest/types').Config.InitialOptions} */
module.exports = {
  testEnvironment: 'jest-allure2-reporter/environment-node',
  reporters: [
    'default',
    ['jest-allure2-reporter', /** @type {import('jest-allure2-reporter').Options}*/ {
      labels: {
        parentSuite: ({ file }) => file.path,
        suite: ({ test }) => test.ancestorTitles[0],
        subsuite: ({ test }) => test.ancestorTitles.slice(1).join(' ') || undefined,
        test: ({ test }) => test.title,
      },
    }],
  ],
};
```

  </TabItem>
</Tabs>

## By Story ðŸ“–

This grouping option stems from the [Behavior-Driven Development](https://en.wikipedia.org/wiki/Behavior-driven_development) (BDD) methodology and
allows users to group test results based on the **epic**, **feature** and **story** to which each test case belongs, where:

* **Epic** is a high-level business goal.
* **Feature** is a functionality that delivers business value.
* **Story** is a user story that describes a feature from the end-user perspective.

This grouping is not enabled by default. Moreover, you need to decide how exactly you want to enable it.

### Annotations API

The [annotation-based approach](../api/08-labels.mdx) gives you a fine-grained control over the names of your Epic, Feature and Story labels, but it requires you to add annotations to your test cases.

In the previous example, it would make sense to group both client and server tests under the same features like **Login screen** and **Forgot password screen**, whereas the epic would be **Authentication**.

### Configuration API

The **configuration-based approach** allows you to group test cases based on the available attributes like file path, ancestor describe blocks, test name and so on.

It's a good option if you don't want to add annotations to your test cases by hand, but it's less flexible than the annotation-based approach. Still, it might be useful if your grouping by suite focuses mostly [on the file structure](#file-oriented-example), and you want to add "a fresh perspective" by grouping tests by describe blocks and test names, for example.

Here's a simple example where we map:

* **epic** to the top-level describe block
* **feature** to the second-level describe block
* **story** to the remaining describe blocks and test name itself

<Tabs groupId="grouping-default">
  <TabItem value="structure" label="Structure">

```plain
â”œâ”€ Login screen
â”‚  â”œâ”€ when loaded
â”‚  â”‚  â””â”€ should display login form
â”‚  â””â”€ when loaded and typed
â”‚     â”œâ”€ should validate e-mail
â”‚     â””â”€ should validate password
â”œâ”€ Forgot password screen
â”‚  â”œâ”€ when loaded
â”‚  â”‚  â””â”€ should display forgot password form
â”‚  â””â”€ when loaded and typed
â”‚     â””â”€ should validate e-mail
â”œâ”€ Login controller
â”‚  â”œâ”€ should return 401 if user is not found
â”‚  â””â”€ should return 401 if password is incorrect
â””â”€ Forgot password controller
   â”œâ”€ should return 401 if user is not found
   â””â”€ should return 401 if password is incorrect
```

  </TabItem>
  <TabItem value="config" label="Config">

```js title="jest.config.js"
/** @type {import('@jest/types').Config.InitialOptions} */
module.exports = {
  testEnvironment: 'jest-allure2-reporter/environment-node',
  reporters: [
    'default',
    ['jest-allure2-reporter', /** @type {import('jest-allure2-reporter').Options}*/ {
      labels: {
        epic: ({ test }) => test.ancestorTitles[0],
        feature: ({ test }) => test.ancestorTitles[1],
        story: ({ test }) => [...test.ancestorTitles.slice(2), test.title].join(' '),
      },
    }],
  ],
};
```

  </TabItem>
</Tabs>

## By Package ðŸ“¦

This grouping feature is the least helpful outside of Java world, where packages are used to organize the codebase.

It strictly follows `com.example.package.ClassName` naming convention, where `com.example.package` is a **package**, `com.example.package.ClassName` is a **test class**, and `shouldAssertAndDoSomething` is a **test method**.

:::caution

It doesn't work well with JavaScript, and, that's why you can use only two grouping levels: **package** and **test method**.

:::

A couple of feasible options are:

* use `package` to group tests by `package.json` name;
* use `package` to group tests by the file path;
* use `testMethod` to group tests by the full test name

<Tabs groupId="grouping-default">
  <TabItem value="structure" label="Structure">

```plain
â””â”€ @my-company/my-package
   â”œâ”€ Forgot password controller should return 401 if password is incorrect
   â”œâ”€ Forgot password controller should return 401 if user is not found
   â”œâ”€ Forgot password screen when loaded and typed should validate e-mail
   â”œâ”€ Forgot password screen when loaded should display forgot password form
   â”œâ”€ Login controller should return 401 if password is incorrect
   â”œâ”€ Login controller should return 401 if user is not found
   â”œâ”€ Login screen when loaded and typed should validate password
   â”œâ”€ Login screen when loaded and typed should validate password
   â””â”€ Login screen when loaded should display login form
```

  </TabItem>
  <TabItem value="config" label="Config">

```js title="jest.config.js"
/** @type {import('@jest/types').Config.InitialOptions} */
module.exports = {
  testEnvironment: 'jest-allure2-reporter/environment-node',
  reporters: [
    'default',
    ['jest-allure2-reporter', /** @type {import('jest-allure2-reporter').Options}*/ {
      labels: {
        package: ({ package }) => package.name,
        // NOTE: `testClass` won't work due to the aforementioned issue
        testClass: ({ file }) => file.path,
        testMethod: ({ test }) => test.fullName,
      },
    }],
  ],
};
```

  </TabItem>
</Tabs>

## Summary

Investing time in properly configuring the grouping options is recommended, especially for projects with a large test codebase. Grouping can significantly enhance the organization and analysis of test results, aiding in effective collaboration and debugging efforts.
